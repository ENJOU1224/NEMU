#include "local-include/reg.h"
#include "local-include/intr.h"
#include <cpu/cpu.h>
#include <cpu/ifetch.h>
#include <cpu/decode.h>
#include <cpu/difftest.h>

#define R(i) gpr(i)
#define Mr(addr, len)       ({ word_t tmp = vaddr_read(s, addr, len, MMU_DYNAMIC); check_ex(); tmp; })
#define Mw(addr, len, data) vaddr_write(s, addr, len, data, MMU_DYNAMIC); check_ex()
#define check_ex() do { \
  if (MUXDEF(CONFIG_PERF_OPT, false, g_ex_cause != NEMU_EXEC_RUNNING)) { \
    cpu.pc = isa_raise_intr(g_ex_cause, s->pc); \
    g_ex_cause = NEMU_EXEC_RUNNING; \
    return 0; \
  } \
} while (0)

enum {
  TYPE_R, TYPE_I, TYPE_J,
  TYPE_U, TYPE_S, TYPE_B,
  TYPE_N, // none

  TYPE_CIW, TYPE_CFLD, TYPE_CLW, TYPE_CLD, TYPE_CFSD, TYPE_CSW, TYPE_CSD,
  TYPE_CI, TYPE_CADDI16SP, TYPE_CLUI, TYPE_CSHIFT,
  TYPE_CANDI, TYPE_CS, TYPE_CJ, TYPE_CB, TYPE_CIU, TYPE_CR,
  TYPE_CFLDSP, TYPE_CLWSP, TYPE_CLDSP,
  TYPE_CFSDSP, TYPE_CSWSP, TYPE_CSDSP,
};

void csrrw(word_t *dest, word_t src, uint32_t csrid);
void csrrs(word_t *dest, word_t src, uint32_t csrid);
word_t priv_instr(uint32_t op, const word_t *src);

static word_t immI(uint32_t i) { return SEXT(BITS(i, 31, 20), 12); }
static word_t immU(uint32_t i) { return SEXT(BITS(i, 31, 12), 20) << 12; }
static word_t immS(uint32_t i) { return (SEXT(BITS(i, 31, 25), 7) << 5) | BITS(i, 11, 7); }
static word_t immJ(uint32_t i) { return (SEXT(BITS(i, 31, 31), 1) << 20) |
  (BITS(i, 19, 12) << 12) | (BITS(i, 20, 20) << 11) | (BITS(i, 30, 21) << 1);
}
static word_t immB(uint32_t i) { return (SEXT(BITS(i, 31, 31), 1) << 12) |
  (BITS(i, 7, 7) << 11) | (BITS(i, 30, 25) << 5) | (BITS(i, 11, 8) << 1);
}

#ifdef CONFIG_PERF_OPT
#include <isa-all-instr.h>
static void decode_i(Operand *op, word_t val)  { op->imm = val; }
static void decode_r(Operand *op, word_t *reg) { op->preg = reg; }

static void decode_operand(Decode *s, word_t *src1, word_t *src2, word_t *imm, int type) {
  static word_t zero_null = 0;
  uint32_t i = s->isa.instr.val;
  int rd  = BITS(i, 11, 7);
  int rs1 = BITS(i, 19, 15);
  int rs2 = BITS(i, 24, 20);
#define Rr(n) &R(n)
#define Rw(n) (n == 0 ? &zero_null : &R(n))
  decode_r(id_dest, (type == TYPE_S ? Rr(rs2) : Rw(rd)));
  switch (type) {
    case TYPE_I: decode_r(id_src1, Rr(rs1)); decode_i(id_src2, immI(i)); break;
    case TYPE_U: decode_i(id_src1, immU(i)); decode_i(id_src2, s->pc + immU(i)); break;
    case TYPE_J: decode_i(id_src1, s->pc + immJ(i)); decode_i(id_src2, s->snpc); break;
    case TYPE_S: decode_r(id_src1, Rr(rs1)); decode_i(id_src2, immS(i)); break;
    case TYPE_B: decode_i(id_dest, s->pc + immB(i)); // fall through
    case TYPE_R: decode_r(id_src1, Rr(rs1)); decode_r(id_src2, Rr(rs2)); break;
  }
}
#else
static void decode_operand(Decode *s, word_t *src1, word_t *src2, word_t *imm, int type) {
  uint32_t i = s->isa.instr.val;
  int rs1 = BITS(i, 19, 15);
  int rs2 = BITS(i, 24, 20);
  switch (type) {
    case TYPE_I: *src1 = R(rs1); *src2 = immI(i); break;
    case TYPE_U: *imm = immU(i); break;
    case TYPE_J: *imm = s->pc + immJ(i); break;
    case TYPE_S: *imm = immS(i); goto R;
    case TYPE_B: *imm = s->pc + immB(i); // fall through
    case TYPE_R: R: *src1 = R(rs1); *src2 = R(rs2); break;
  }
}

#endif

static void jcond(bool cond, vaddr_t target) {
  if (cond) cpu.pc = target;
}

static word_t sextw(word_t x) { return (int64_t)(int32_t)x; }

static int decode_exec(Decode *s) {
  int rd = BITS(s->isa.instr.val, 11, 7);
  word_t imm = 0, src1 = 0, src2 = 0;
  cpu.pc = s->snpc;

#define INSTPAT_INST(s) ((s)->isa.instr.val)
#define INSTPAT_MATCH(s, name, type, ... /* body */ ) { \
  decode_operand(s, &src1, &src2, &imm, concat(TYPE_, type)); \
  IFDEF(CONFIG_PERF_OPT, return concat(EXEC_ID_, name)); \
  __VA_ARGS__ ; \
}

  INSTPAT_START();
#ifdef CONFIG_PERF_OPT
  int rs1 = BITS(s->isa.instr.val, 19, 15);
  INSTPAT("0000000 00000 00001 ??? 00000 11001 11", p_ret    , I);
  INSTPAT("0000000 00000 ????? ??? 00000 11001 11", c_jr     , I);
  INSTPAT("??????? ????? ????? ??? 00000 11011 11", c_j      , J);
  INSTPAT("??????? ????? ????? ??? 00001 11011 11", c_jal    , J);
  INSTPAT("??????? 00000 ????? 000 ????? 11000 11", c_beqz   , B);
  INSTPAT("??????? 00000 ????? 001 ????? 11000 11", c_bnez   , B);
  INSTPAT("??????? 00000 ????? 100 ????? 11000 11", p_bltz   , B);
  INSTPAT("??????? 00000 ????? 101 ????? 11000 11", p_bgez   , B);
  INSTPAT("??????? ????? 00000 100 ????? 11000 11", p_bgtz   , B);
  INSTPAT("??????? ????? 00000 101 ????? 11000 11", p_blez   , B);
  INSTPAT("0000000 00000 00000 000 ????? 00100 11", p_li_0   , I);
  INSTPAT("0000000 00001 00000 000 ????? 00100 11", p_li_1   , I);
  INSTPAT("??????? ????? 00000 000 ????? 00100 11", c_li     , I);
  INSTPAT("0000000 00000 ????? 000 ????? 00100 11", c_mv     , I);
if (rd == rs1) {
  INSTPAT("0000000 ????? ????? 000 ????? 01100 11", c_add    , R);
  INSTPAT("0100000 ????? ????? 000 ????? 01100 11", c_sub    , R);
  INSTPAT("0000000 ????? ????? 100 ????? 01100 11", c_xor    , R);
  INSTPAT("0000000 ????? ????? 110 ????? 01100 11", c_or     , R);
  INSTPAT("0000000 ????? ????? 111 ????? 01100 11", c_and    , R);
  INSTPAT("0000000 00001 ????? 000 ????? 00100 11", p_inc    , I);
  INSTPAT("1111111 11111 ????? 000 ????? 00100 11", p_dec    , I);
  INSTPAT("??????? ????? ????? 000 ????? 00100 11", c_addi   , I);
  INSTPAT("??????? ????? ????? 111 ????? 00100 11", c_andi   , I);
  INSTPAT("0000000 ????? ????? 001 ????? 00100 11", c_slli   , I);
  INSTPAT("0100000 ????? ????? 101 ????? 00100 11", c_srai   , I);
  INSTPAT("0000000 ????? ????? 101 ????? 00100 11", c_srli   , I);
}
int mmu_mode = isa_mmu_state();
if (mmu_mode == MMU_TRANSLATE) {
  INSTPAT("??????? ????? ????? 000 ????? 00000 11", lb_mmu   , I);
  INSTPAT("??????? ????? ????? 001 ????? 00000 11", lh_mmu   , I);
  INSTPAT("??????? ????? ????? 010 ????? 00000 11", lw_mmu   , I);
  INSTPAT("??????? ????? ????? 011 ????? 00000 11", ld_mmu   , I);
  INSTPAT("??????? ????? ????? 100 ????? 00000 11", lbu_mmu  , I);
  INSTPAT("??????? ????? ????? 101 ????? 00000 11", lhu_mmu  , I);
  INSTPAT("??????? ????? ????? 110 ????? 00000 11", lwu_mmu  , I);
  INSTPAT("??????? ????? ????? 000 ????? 01000 11", sb_mmu   , S);
  INSTPAT("??????? ????? ????? 001 ????? 01000 11", sh_mmu   , S);
  INSTPAT("??????? ????? ????? 010 ????? 01000 11", sw_mmu   , S);
  INSTPAT("??????? ????? ????? 011 ????? 01000 11", sd_mmu   , S);
}
#endif
  // rv32i
  INSTPAT("??????? ????? ????? ??? ????? 01101 11", lui      , U, R(rd) = imm);
  INSTPAT("??????? ????? ????? ??? ????? 00101 11", auipc    , U, R(rd) = imm + s->pc);
  INSTPAT("??????? ????? ????? ??? ????? 11011 11", jal      , J, jcond(true, imm); R(rd) = s->snpc);
  INSTPAT("??????? ????? ????? ??? ????? 11001 11", jalr     , I, jcond(true, src1 + src2); R(rd) = s->snpc);
  INSTPAT("??????? ????? ????? 000 ????? 11000 11", beq      , B, jcond(src1 == src2, imm));
  INSTPAT("??????? ????? ????? 001 ????? 11000 11", bne      , B, jcond(src1 != src2, imm));
  INSTPAT("??????? ????? ????? 100 ????? 11000 11", blt      , B, jcond((sword_t)src1 <  (sword_t)src2, imm));
  INSTPAT("??????? ????? ????? 101 ????? 11000 11", bge      , B, jcond((sword_t)src1 >= (sword_t)src2, imm));
  INSTPAT("??????? ????? ????? 110 ????? 11000 11", bltu     , B, jcond(src1 <  src2, imm));
  INSTPAT("??????? ????? ????? 111 ????? 11000 11", bgeu     , B, jcond(src1 >= src2, imm));
  INSTPAT("??????? ????? ????? 000 ????? 00000 11", lb       , I, R(rd) = SEXT(Mr(src1 + src2, 1), 8));
  INSTPAT("??????? ????? ????? 001 ????? 00000 11", lh       , I, R(rd) = SEXT(Mr(src1 + src2, 2), 16));
  INSTPAT("??????? ????? ????? 010 ????? 00000 11", lw       , I, R(rd) = SEXT(Mr(src1 + src2, 4), 32));
  INSTPAT("??????? ????? ????? 100 ????? 00000 11", lbu      , I, R(rd) = Mr(src1 + src2, 1));
  INSTPAT("??????? ????? ????? 101 ????? 00000 11", lhu      , I, R(rd) = Mr(src1 + src2, 2));
  INSTPAT("??????? ????? ????? 000 ????? 01000 11", sb       , S, Mw(src1 + imm, 1, src2));
  INSTPAT("??????? ????? ????? 001 ????? 01000 11", sh       , S, Mw(src1 + imm, 2, src2));
  INSTPAT("??????? ????? ????? 010 ????? 01000 11", sw       , S, Mw(src1 + imm, 4, src2));
  INSTPAT("??????? ????? ????? 000 ????? 00100 11", addi     , I, R(rd) = src1 + src2);
  INSTPAT("??????? ????? ????? 010 ????? 00100 11", slti     , I, R(rd) = (sword_t)src1 < (sword_t)src2);
  INSTPAT("??????? ????? ????? 011 ????? 00100 11", sltiu    , I, R(rd) = src1 <  src2);
  INSTPAT("??????? ????? ????? 100 ????? 00100 11", xori     , I, R(rd) = src1 ^  src2);
  INSTPAT("??????? ????? ????? 110 ????? 00100 11", ori      , I, R(rd) = src1 |  src2);
  INSTPAT("??????? ????? ????? 111 ????? 00100 11", andi     , I, R(rd) = src1 &  src2);
  INSTPAT("000000? ????? ????? 001 ????? 00100 11", slli     , I, R(rd) = src1 << src2);
  INSTPAT("000000? ????? ????? 101 ????? 00100 11", srli     , I, R(rd) = src1 >> src2);
  INSTPAT("010000? ????? ????? 101 ????? 00100 11", srai     , I, R(rd) = (sword_t)src1 >> (src2 & 0x3f));
  INSTPAT("0000000 ????? ????? 000 ????? 01100 11", add      , R, R(rd) = src1 +  src2);
  INSTPAT("0100000 ????? ????? 000 ????? 01100 11", sub      , R, R(rd) = src1 -  src2);
  INSTPAT("0000000 ????? ????? 001 ????? 01100 11", sll      , R, R(rd) = src1 << src2);
  INSTPAT("0000000 ????? ????? 010 ????? 01100 11", slt      , R, R(rd) = (sword_t)src1 <  (sword_t)src2);
  INSTPAT("0000000 ????? ????? 011 ????? 01100 11", sltu     , R, R(rd) = src1 <  src2);
  INSTPAT("0000000 ????? ????? 100 ????? 01100 11", xor      , R, R(rd) = src1 ^  src2);
  INSTPAT("0000000 ????? ????? 101 ????? 01100 11", srl      , R, R(rd) = src1 >> src2);
  INSTPAT("0100000 ????? ????? 101 ????? 01100 11", sra      , R, R(rd) = (sword_t)src1 >> src2);
  INSTPAT("0000000 ????? ????? 110 ????? 01100 11", or       , R, R(rd) = src1 |  src2);
  INSTPAT("0000000 ????? ????? 111 ????? 01100 11", and      , R, R(rd) = src1 &  src2);
  INSTPAT("??????? ????? ????? 000 ????? 00011 11", fence    , I); // do nothing in non-perf mode
  INSTPAT("??????? ????? ????? 001 ????? 00011 11", fence_i  , I); // do nothing in non-perf mode

  // rv64i
  INSTPAT("??????? ????? ????? 110 ????? 00000 11", lwu      , I, R(rd) = Mr(src1 + src2, 4));
  INSTPAT("??????? ????? ????? 011 ????? 00000 11", ld       , I, R(rd) = Mr(src1 + src2, 8));
  INSTPAT("??????? ????? ????? 011 ????? 01000 11", sd       , S, Mw(src1 + imm, 8, src2));
//  if (s->isa.instr.i.rd == s->isa.instr.i.rs1) {
//    def_INSTR_TAB("??????? ????? ????? 000 ????? ????? ??", c_addiw_dispatch);
//    def_INSTR_TAB("0000000 ????? ????? 000 ????? ????? ??", c_addw);
//    def_INSTR_TAB("0100000 ????? ????? 000 ????? ????? ??", c_subw);
//  }
//  def_INSTR_TAB("0000000 00000 ????? 000 ????? ????? ??", p_sext_w);
  INSTPAT("??????? ????? ????? 000 ????? 00110 11", addiw    , I, R(rd) = sextw(src1 + src2));
  INSTPAT("0000000 ????? ????? 001 ????? 00110 11", slliw    , I, R(rd) = sextw((uint32_t)src1 << (src2 & 0x1f)));
  INSTPAT("0000000 ????? ????? 101 ????? 00110 11", srliw    , I, R(rd) = sextw((uint32_t)src1 >> (src2 & 0x1f)));
  INSTPAT("0100000 ????? ????? 101 ????? 00110 11", sraiw    , I, R(rd) = sextw(( int32_t)src1 >> (src2 & 0x1f)));
  INSTPAT("0000000 ????? ????? 000 ????? 01110 11", addw     , R, R(rd) = sextw(src1 + src2));
  INSTPAT("0100000 ????? ????? 000 ????? 01110 11", subw     , R, R(rd) = sextw(src1 - src2));
  INSTPAT("0000000 ????? ????? 001 ????? 01110 11", sllw     , R, R(rd) = sextw((uint32_t)src1 << (src2 & 0x1f)));
  INSTPAT("0000000 ????? ????? 101 ????? 01110 11", srlw     , R, R(rd) = sextw((uint32_t)src1 >> (src2 & 0x1f)));
  INSTPAT("0100000 ????? ????? 101 ????? 01110 11", sraw     , R, R(rd) = sextw(( int32_t)src1 >> (src2 & 0x1f)));

  // rv32m
  INSTPAT("0000001 ????? ????? 000 ????? 01100 11", mul      , R, R(rd) = src1 *  src2);
  INSTPAT("0000001 ????? ????? 001 ????? 01100 11", mulh     , R,
      R(rd) = ((__int128_t)(sword_t)src1 *  (__int128_t)(sword_t)src2) >> 64);
  INSTPAT("0000001 ????? ????? 010 ????? 01100 11", mulhsu   , R,
      word_t hi = ((__uint128_t)src1 *  (__uint128_t)src2) >> 64;
      R(rd) = hi - ((sword_t)src1  < 0 ? src2 : 0));
  INSTPAT("0000001 ????? ????? 011 ????? 01100 11", mulhu    , R,
      R(rd) = ((__uint128_t)src1 *  (__uint128_t)src2) >> 64);
  INSTPAT("0000001 ????? ????? 100 ????? 01100 11", div      , R, R(rd) = (sword_t)src1 /  (sword_t)src2);
  INSTPAT("0000001 ????? ????? 101 ????? 01100 11", divu     , R, R(rd) = src1 /  src2);
  INSTPAT("0000001 ????? ????? 110 ????? 01100 11", rem      , R, R(rd) = (sword_t)src1 %  (sword_t)src2);
  INSTPAT("0000001 ????? ????? 111 ????? 01100 11", remu     , R, R(rd) = src1 %  src2);

  // rv64m
  INSTPAT("0000001 ????? ????? 000 ????? 01110 11", mulw     , R, R(rd) = sextw(src1 * src2));
  INSTPAT("0000001 ????? ????? 100 ????? 01110 11", divw     , R, R(rd) = sextw(( int32_t)src1 / ( int32_t)src2));
  INSTPAT("0000001 ????? ????? 101 ????? 01110 11", divuw    , R, R(rd) = sextw((uint32_t)src1 / (uint32_t)src2));
  INSTPAT("0000001 ????? ????? 110 ????? 01110 11", remw     , R, R(rd) = sextw(( int32_t)src1 % ( int32_t)src2));
  INSTPAT("0000001 ????? ????? 111 ????? 01110 11", remuw    , R, R(rd) = sextw((uint32_t)src1 % (uint32_t)src2));

  // privileged
//  INSTPAT("0000000 00000 00000 000 00000 11100 11", ecall    , N, cpu.pc = isa_raise_intr(cpu.mode + 8, s->pc));
//  INSTPAT("0011000 00010 00000 000 00000 11100 11", mret     , I, cpu.pc = priv_instr(src2, NULL));
//  INSTPAT("0001001 ????? ????? 000 00000 11100 11", sfence_vma,I); // do nothing in non-perf mode
//  INSTPAT("??????? ????? ????? 001 ????? 11100 11", csrrw    , I, csrrw(&R(rd), src1, src2));
//  INSTPAT("??????? ????? ????? 010 ????? 11100 11", csrrs    , I, csrrs(&R(rd), src1, src2));

  INSTPAT("??????? ????? ????? ??? ????? 11010 11", nemu_trap, N, NEMUTRAP(s->pc, R(10))); // R(10) is $a0
  INSTPAT("??????? ????? ????? ??? ????? ????? ??", inv      , N, INV(s->pc));
  INSTPAT_END();

  R(0) = 0; // reset $zero to 0

  return 0;
}

#define creg2reg(creg) (creg + 8)

static uint32_t ror_imm(uint32_t imm, int len, int r) {
  if (r == 0) return imm;
  uint32_t copy = imm | (imm << len);
  uint32_t mask = BITMASK(len) << r;
  return copy & mask;
}

static word_t immCIW(uint32_t i) {
  uint32_t imm9_6 = ror_imm(BITS(i, 12, 7), 6, 4); // already at the right place
  uint32_t imm = imm9_6 | BITS(i, 5, 5) << 3 | BITS(i, 6, 6) << 2;
  assert(imm != 0);
  return imm;
}

static word_t imm_CLDST(uint32_t i, int rotate) {
  uint32_t imm5 = (BITS(i, 12, 10) << 2) | BITS(i, 6, 5);
  return ror_imm(imm5, 5, rotate) << 1;
}

static word_t immCI(uint32_t i, bool sign, int shift, int rotate) {
  uint32_t imm6 = (BITS(i, 12, 12) << 5) | BITS(i, 6, 2);
  return sign ? SEXT(imm6, 6) << shift : ror_imm(imm6, 6, rotate);
}

static word_t immCJ(uint32_t i) {
  return (SEXT(BITS(i, 12, 12), 1) << 11) | (BITS(i, 8, 8) << 10) | (BITS(i, 10, 9) << 8) |
    (BITS(i, 6, 6) << 7) | (BITS(i, 7, 7) << 6) | (BITS(i, 2, 2) << 5) |
    (BITS(i, 11, 11) << 4) | (BITS(i, 5, 3) << 1);
}

static word_t immCB(uint32_t i) {
  return (SEXT(BITS(i, 12, 12), 1) << 8) | (BITS(i, 6, 5) << 6) |
    (BITS(i, 2, 2) << 5) | (BITS(i, 11, 10) << 3) | (BITS(i, 4, 3) << 1);
}

static word_t immCSS(uint32_t i, int rotate) {
  uint32_t imm6 = BITS(i, 12, 7);
  return ror_imm(imm6, 6, rotate);
}

static void decode_operand_rvc(Decode *s, int *rd, word_t *src1, word_t *src2, word_t *imm, int type) {
  uint32_t i = s->isa.instr.val;
  switch (type) {
    case TYPE_CIW: *rd = creg2reg(BITS(i, 4, 2)); *src1 = R(2); *src2 = immCIW(i); break;
    case TYPE_CLW: *src2 = imm_CLDST(i, 1); goto CL;
    case TYPE_CLD: *src2 = imm_CLDST(i, 2); // fall through
    CL:
      *rd = creg2reg(BITS(i, 4, 2));
      *src1 = R(creg2reg(BITS(i, 9, 7)));
      break;
    case TYPE_CSW: *imm = imm_CLDST(i, 1); goto CW;
    case TYPE_CSD: *imm = imm_CLDST(i, 2); // fall through
    CW:
      *src1 = R(creg2reg(BITS(i, 9, 7)));
      *src2 = R(creg2reg(BITS(i, 4, 2)));
      break;
    case TYPE_CI:
      *rd = BITS(i, 11, 7);
      *src1 = R(*rd);
      *src2 = immCI(i, true, 0, 0);
      break;
    case TYPE_CADDI16SP:
      *rd = 2;
      *src1 = R(*rd);
      *src2 = (SEXT(BITS(i, 12, 12), 1) << 9) | (BITS(i, 4, 3) << 7) |
        (BITS(i, 5, 5) << 6) | (BITS(i, 2, 2) << 5) | (BITS(i, 6, 6) << 4);
      break;
    case TYPE_CLUI:
      *rd = BITS(i, 11, 7);
      *src2 = immCI(i, true, 0, 0) << 12;
      break;
    case TYPE_CSHIFT:
      *rd = creg2reg(BITS(i, 9, 7));
      *src1 = R(*rd);
      *src2 = immCI(i, false, 0, 0);
      break;
    case TYPE_CANDI:
      *rd = creg2reg(BITS(i, 9, 7));
      *src1 = R(*rd);
      *src2 = immCI(i, true, 0, 0);
      break;
    case TYPE_CS:
      *rd = creg2reg(BITS(i, 9, 7));
      *src1 = R(*rd);
      *src2 = R(creg2reg(BITS(i, 4, 2)));
      break;
    case TYPE_CJ: *imm = s->pc + immCJ(i); break;
    case TYPE_CB: *src1 = R(creg2reg(BITS(i, 9, 7))); *imm = s->pc + immCB(i); break;
    case TYPE_CIU:
      *rd = BITS(i, 11, 7);
      *src1 = R(*rd);
      *src2 = immCI(i, false, 0, 0);
      break;
    case TYPE_CFLDSP: *src2 = immCI(i, false, 0, 3); goto CI_ld;
    case TYPE_CLWSP:  *src2 = immCI(i, false, 0, 2); goto CI_ld;
    case TYPE_CLDSP:  *src2 = immCI(i, false, 0, 3); // fall through
    CI_ld:
      *rd = BITS(i, 11, 7);
      *src1 = R(2);
      break;
    case TYPE_CFSDSP: *imm = immCSS(i, 3); goto CSS;
    case TYPE_CSWSP:  *imm = immCSS(i, 2); goto CSS;
    case TYPE_CSDSP:  *imm = immCSS(i, 3); // fall through
    CSS:
      *src1 = R(2);
      *src2 = R(BITS(i, 6, 2));
      break;
    case TYPE_CR:
      *rd = BITS(i, 11, 7);
      *src1 = R(*rd);
      *src2 = R(BITS(i, 6, 2));
      break;
  }
}

static int decode_exec_rvc(Decode *s) {
  int rd = 0;
  word_t imm = 0, src1 = 0, src2 = 0;
  cpu.pc = s->snpc;

#undef INSTPAT_MATCH
#define INSTPAT_MATCH(s, name, type, ... /* body */ ) { \
  decode_operand_rvc(s, &rd, &src1, &src2, &imm, concat(TYPE_, type)); \
  IFDEF(CONFIG_PERF_OPT, return concat(EXEC_ID_, name)); \
  __VA_ARGS__ ; \
}

  INSTPAT_START();
#ifdef CONFIG_PERF_OPT
#endif
  // Q0
  INSTPAT("000  00000000  000 00", inv    , N   , INV(s->pc));
  INSTPAT("000  ????????  ??? 00", addi   , CIW , R(rd) = src1 + src2); // C.ADDI2SPN
  INSTPAT("001 ??? ??? ?? ??? 00", fld    , CFLD, assert(0));
  INSTPAT("010 ??? ??? ?? ??? 00", lw     , CLW , R(rd) = SEXT(Mr(src1 + src2, 4), 32));
  INSTPAT("011 ??? ??? ?? ??? 00", ld     , CLD , R(rd) = Mr(src1 + src2, 8));
  INSTPAT("101 ??? ??? ?? ??? 00", fsd    , CFSD, assert(0));
  INSTPAT("110 ??? ??? ?? ??? 00", sw     , CSW , Mw(src1 + imm, 4, src2));
  INSTPAT("111 ??? ??? ?? ??? 00", sd     , CSD , Mw(src1 + imm, 8, src2));

  // Q1
  INSTPAT("000 ? ????? ????? 01", addi    , CI , R(rd) = src1 + src2);
  INSTPAT("001 ? ????? ????? 01", addiw   , CI , R(rd) = sextw(src1 + src2));
  INSTPAT("010 ? ????? ????? 01", addi    , CI , R(rd) = src2);  // C.LI
  INSTPAT("011 ? 00010 ????? 01", addi    , CADDI16SP, R(rd) = src1 + src2); // C.ADDI16SP
  INSTPAT("011 ? ????? ????? 01", lui     , CLUI,R(rd) = src2);
  INSTPAT("100 ? 00??? ????? 01", srli    , CSHIFT, R(rd) = src1 >> src2);
  INSTPAT("100 ? 01??? ????? 01", srai    , CSHIFT, R(rd) = (sword_t)src1 >> src2);
  INSTPAT("100 ? 10??? ????? 01", andi    , CANDI , R(rd) = src1 & src2);
  INSTPAT("100 0 11??? 00??? 01", sub     , CS, R(rd) = src1 - src2);
  INSTPAT("100 0 11??? 01??? 01", xor     , CS, R(rd) = src1 ^ src2);
  INSTPAT("100 0 11??? 10??? 01", or      , CS, R(rd) = src1 | src2);
  INSTPAT("100 0 11??? 11??? 01", and     , CS, R(rd) = src1 & src2);
  INSTPAT("100 1 11??? 00??? 01", subw    , CS, R(rd) = sextw(src1 - src2));
  INSTPAT("100 1 11??? 01??? 01", addw    , CS, R(rd) = sextw(src1 + src2));
  INSTPAT("101  ???????????  01", j       , CJ, jcond(true, imm));
  INSTPAT("110 ??? ??? ????? 01", beqz    , CB, jcond(src1 == 0, imm));
  INSTPAT("111 ??? ??? ????? 01", bnez    , CB, jcond(src1 != 0, imm));

  // Q2
  INSTPAT("000 ? ????? ????? 10", slli    , CIU, R(rd) = src1 << src2);
  INSTPAT("001 ? ????? ????? 10", fld     , CFLDSP, assert(0));
  INSTPAT("010 ? ????? ????? 10", lw      , CLWSP , R(rd) = SEXT(Mr(src1 + src2, 4), 32));
  INSTPAT("011 ? ????? ????? 10", ld      , CLDSP , R(rd) = Mr(src1 + src2, 8));

//  INSTPAT("??? ? 00001 00000 10", C_JR   , p_ret);
  INSTPAT("100 0 ????? 00000 10", c_jr   , CR, jcond(true, src1));
  INSTPAT("100 0 ????? ????? 10", c_mv   , CR, R(rd) = src2);
  INSTPAT("100 1 00000 00000 10", inv    , N);  // ebreak
//  INSTPAT("100 ? 00001 00000 10", C_JALR , jalr); // c_jalr can not handle correctly when rs1 == ra
  INSTPAT("100 1 ????? 00000 10", c_jalr , CR, jcond(true, src1); R(1) = s->snpc);
  INSTPAT("100 1 ????? ????? 10", c_add  , CR, R(rd) = src1 + src2);

  INSTPAT("101 ? ????? ????? 10", fsd     , CFSDSP, assert(0));
  INSTPAT("110 ? ????? ????? 10", sw      , CSWSP , Mw(src1 + imm, 4, src2));
  INSTPAT("111 ? ????? ????? 10", sd      , CSDSP , Mw(src1 + imm, 8, src2));

  INSTPAT("??? ??? ??? ?? ??? ??", inv    , N  , INV(s->pc));
  INSTPAT_END();

  R(0) = 0; // reset $zero to 0

  return 0;
}

int isa_fetch_decode(Decode *s) {
  int idx = 0;
  s->isa.instr.val = instr_fetch(&s->snpc, 2);
  if (BITS(s->isa.instr.val, 1, 0) != 0x3) {
    // this is an RVC instruction
    idx = decode_exec_rvc(s);
  } else {
    // this is a 4-byte instruction, should fetch the MSB part
    // NOTE: The fetch here may cause IPF.
    // If it is the case, we should have mepc = xxxffe and mtval = yyy000.
    // Refer to `mtval` in the privileged manual for more details.
    uint32_t hi = instr_fetch(&s->snpc, 2);
    s->isa.instr.val |= (hi << 16);
    idx = decode_exec(s);
  }
#ifdef CONFIG_PERF_OPT
  s->type = INSTR_TYPE_N;
  switch (idx) {
    case EXEC_ID_c_j: case EXEC_ID_p_jal: case EXEC_ID_jal:
      s->jnpc = id_src1->imm; s->type = INSTR_TYPE_J; break;

    case EXEC_ID_beq: case EXEC_ID_bne: case EXEC_ID_blt: case EXEC_ID_bge:
    case EXEC_ID_bltu: case EXEC_ID_bgeu:
    case EXEC_ID_c_beqz: case EXEC_ID_c_bnez:
    case EXEC_ID_p_bltz: case EXEC_ID_p_bgez: case EXEC_ID_p_blez: case EXEC_ID_p_bgtz:
      s->jnpc = id_dest->imm; s->type = INSTR_TYPE_B; break;

    case EXEC_ID_p_ret: case EXEC_ID_c_jr: case EXEC_ID_c_jalr: case EXEC_ID_jalr:
      s->type = INSTR_TYPE_I; break;

    case EXEC_ID_system:
      if (s->isa.instr.i.funct3 == 0) {
        switch (s->isa.instr.csr.csr) {
          case 0:     // ecall
          case 0x102: // sret
          case 0x302: // mret
            s->type = INSTR_TYPE_I;
        }
      }
      break;
  }
#endif
  return idx;
}
