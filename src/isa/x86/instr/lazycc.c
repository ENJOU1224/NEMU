#include "lazycc.h"

#ifdef CONFIG_x86_CC_LAZY
#define NEGCC(cc) ((cc)%2 == 1)
#define NEGCCRELOP(cc) (NEGCC(cc) ? RELOP_NE : RELOP_EQ)
#define MASKDEST(reg) \
  p = &cpu.cc_dest; \
  if (cpu.cc_width != 4) { rtl_andi(s, reg, &cpu.cc_dest, 0xffffffffu >> ((4 - cpu.cc_width) * 8)); p = reg;}

static const int cc2relop_sub[16] = {
  [CC_B]  = RELOP_LTU,
  [CC_E]  = RELOP_EQ,
  [CC_BE] = RELOP_LEU,
  [CC_S]  = RELOP_LT,
  [CC_L]  = RELOP_LT,
  [CC_LE] = RELOP_LE,
};

static const int cc2relop_logic[16] = {
  [CC_O]  = RELOP_FALSE,
  [CC_B]  = RELOP_LTU,
  [CC_BE] = RELOP_LEU,
  [CC_L]  = RELOP_LT,
  [CC_LE] = RELOP_LE,
};

static void lazycc_codegen(Decode *s, CCop *op, bool setcc_ok,
    int relop, const rtlreg_t *src1, const rtlreg_t *src2) {
  relop ^= op->invert;
  if (op->type == CCTYPE_SETCC) {
    if (setcc_ok) {
      if (op->invert) rtl_xori(s, op->dest, op->dest, 0x1);
    }
    else rtl_setrelop(s, relop, op->dest, src1, src2);
  } else {
    // For CCTYPE_JCC, we only record the info here.
    // The code will be generated by rtl_jrelop() in exec_jcc().
    op->relop = relop;
    op->src1 = src1;
    op->src2 = src2;
  }
}

static void lazycc_P(Decode *s, CCop *op, rtlreg_t *tmp) {
  rtlreg_t *p = &cpu.cc_dest; // result to compute the parity bit
  switch (cpu.cc_op) {
    case LAZYCC_FCMP: case LAZYCC_FCMP_SAME: lazycc_codegen(s, op, false, RELOP_FALSE, tmp, rz); return;
    case LAZYCC_SUB: rtl_sub(s, tmp, &cpu.cc_dest, &cpu.cc_src1); p = tmp;
  }

  // start:                     p  = ????76543210
  rtl_srli(s, t0, p, 4);    //  t0 =     ????7654
  rtl_xor(s, t0, t0, p);    //  t0 =    ????(7^3)(6^2)(5^1)(4^0)
  rtl_srli(s, tmp, t0, 2);  // tmp =      ??  ?    ?  (7^3)(6^2)
  rtl_xor(s, t0, t0, tmp);  //  t0 =          ?    ?  (7^3^5^1)(6^2^4^0)
  rtl_srli(s, tmp, t0, 1);  // tmp =                      ?    (7^3^5^1)
  rtl_xor(s, t0, t0, tmp);  //  t0 =                      ?    (7^6^5^4^3^2^1^0)
  rtl_andi(s, tmp, t0, 1);  // tmp = !PF
  lazycc_codegen(s, op, false, RELOP_EQ, tmp, rz);
}

static void lazycc_E(Decode *s, CCop *op, rtlreg_t *tmp) {
  switch (cpu.cc_op) {
    case LAZYCC_FCMP_SAME: lazycc_codegen(s, op, false, RELOP_TRUE, tmp, rz); return;
    case LAZYCC_FCMP:
      if (op->type == CCTYPE_SETCC) { rtl_mv(s, tmp, &cpu.cc_src1); }
      else { tmp = &cpu.cc_src1; }
      lazycc_codegen(s, op, true, RELOP_NE, tmp, rz);
      return;
    case LAZYCC_SUB:
      lazycc_codegen(s, op, false, RELOP_EQ, &cpu.cc_dest, &cpu.cc_src1);
      return;
  }

  rtlreg_t *p = &cpu.cc_dest; // result to compute the zero bit
  if (cpu.cc_width != 4 && cpu.cc_op != LAZYCC_LOGIC) {
    rtl_slli(s, tmp, &cpu.cc_dest, 32 - cpu.cc_width * 8);
    p = tmp;
  }
  lazycc_codegen(s, op, false, RELOP_EQ, p, rz);
}

static void lazycc_S(Decode *s, CCop *op, rtlreg_t *tmp) {
  rtlreg_t *p = &cpu.cc_dest; // result to compute the sign bit
  switch (cpu.cc_op) {
    case LAZYCC_FCMP_SAME: case LAZYCC_FCMP: assert(0);
    case LAZYCC_SUB: rtl_sub(s, tmp, &cpu.cc_dest, &cpu.cc_src1); p = tmp;
  }

  if (cpu.cc_width != 4) {
    rtl_slli(s, tmp, p, 32 - cpu.cc_width * 8);
    p = tmp;
  }
  lazycc_codegen(s, op, false, RELOP_LT, p, rz);
}

static void lazycc_add(Decode *s, CCop *op, rtlreg_t *tmp, uint32_t cc) {
  switch (cc) {
    case CC_O:
      rtl_sub(s, tmp, &cpu.cc_dest, &cpu.cc_src1);
      rtl_is_add_overflow(s, tmp, &cpu.cc_dest, &cpu.cc_src1, tmp, cpu.cc_width);
      lazycc_codegen(s, op, true, RELOP_NE, tmp, rz);
      return;
#if 0
    case CC_LE:
      rtl_sub(s, dest, &cpu.cc_dest, &cpu.cc_src1);
      rtl_is_add_overflow(s, s0, &cpu.cc_dest, &cpu.cc_src1, dest, cpu.cc_width);
      rtl_msb(s, s1, &cpu.cc_dest, cpu.cc_width);
      rtl_xor(s, dest, s0, s1);
      MASKDEST(s0);
      rtl_setrelopi(s, RELOP_EQ, s0, p, 0);
      rtl_or(s, dest, dest, s0);
      goto negcc_reverse;
      return;
    case CC_BE:
      MASKDEST(s0);
      rtl_is_add_carry(s, s1, p, &cpu.cc_src1);
      rtl_setrelopi(s, RELOP_EQ, s0, p, 0);
      rtl_or(s, dest, s0, s1);
      goto negcc_reverse;
      return;
#endif
  }
  Assert(cc2relop_sub[cc] != 0, "unhandle cc = %d at pc = " FMT_WORD, cc, s->extraInfo->pc);
  rtlreg_t *p = &cpu.cc_dest;
  if (cpu.cc_width != 4) {
    rtl_andi(s, tmp, &cpu.cc_dest, 0xffffffffu >> ((4 - cpu.cc_width) * 8));
    p = tmp;
  }
  lazycc_codegen(s, op, false, cc2relop_sub[cc], p, &cpu.cc_src1);
}

static void lazycc_sub(Decode *s, CCop *op, rtlreg_t *tmp, uint32_t cc) {
  switch (cc) {
    case CC_O:
      rtl_sub(s, tmp, &cpu.cc_dest, &cpu.cc_src1);
      rtl_is_sub_overflow(s, tmp, tmp, &cpu.cc_dest, &cpu.cc_src1, cpu.cc_width);
      lazycc_codegen(s, op, true, RELOP_NE, tmp, rz);
      return;
  }
  if (cc2relop_sub[cc] != 0) {
    rtlreg_t *pdest = &cpu.cc_dest;
    rtlreg_t *psrc1 = &cpu.cc_src1;
    if (cpu.cc_width != 4) {
      if (cc == CC_L || cc == CC_LE) {
        rtl_slli(s, tmp, pdest, 32 - cpu.cc_width * 8);
        rtl_slli(s, t0,  psrc1, 32 - cpu.cc_width * 8);
        pdest = tmp;
        psrc1 = t0;
      }
    }
    //rtl_setrelop(s, cc2relop_sub[cc] & 0xf, dest, &cpu.cc_dest, &cpu.cc_src1);
    lazycc_codegen(s, op, false, cc2relop_sub[cc], pdest, psrc1);
  }
}

static void lazycc_neg(Decode *s, CCop *op, rtlreg_t *tmp, uint32_t cc) {
  switch (cc) {
    case CC_B: lazycc_codegen(s, op, false, RELOP_NE, &cpu.cc_dest, rz); break;
    default: panic("unhandle cc = %d at pc = " FMT_WORD, cc, s->extraInfo->pc);
#if 0
    case CC_O: case CC_NO:
      rtl_setrelopi(s, NEGCCRELOP(cc), dest, &cpu.cc_dest, -(0x1u << (cpu.cc_width * 8 - 1)));
      return;
    case CC_L: case CC_NL:
      rtl_setrelopi(s, NEGCCRELOP(cc), s0, &cpu.cc_dest, -(0x1u << (cpu.cc_width * 8 - 1)));
      rtl_msb(s, s1, &cpu.cc_dest, cpu.cc_width);
      rtl_xor(s, dest, s0, s1);
      return;
    case CC_LE: case CC_NLE:
      rtl_setrelopi(s, RELOP_EQ, s0, &cpu.cc_dest, -(0x1u << (cpu.cc_width * 8 - 1)));
      rtl_msb(s, s1, &cpu.cc_dest, cpu.cc_width);
      rtl_xor(s, dest, s0, s1);
      rtl_setrelopi(s, RELOP_EQ, s0, &cpu.cc_dest, 0);
      rtl_or(s, dest, dest, s0);
      goto negcc_reverse;
      return;
    case CC_BE:
      rtl_li(s, dest, 1);
      return;
    case CC_NBE:
      rtl_li(s, dest, 0);
      return;
#endif
  }
}

static void lazycc_inc(Decode *s, CCop *op, rtlreg_t *tmp, uint32_t cc) {
  switch (cc) {
    // CF is already stored in cpu.cc_src1
    case CC_B: lazycc_codegen(s, op, false, RELOP_NE, &cpu.cc_src1, rz); break;
    default: panic("unhandle cc = %d at pc = " FMT_WORD, cc, s->extraInfo->pc);
#if 0
    case CC_O: case CC_NO:
      rtl_setrelopi(s, NEGCCRELOP(cc), dest, &cpu.cc_dest, 0x1u << (cpu.cc_width * 8 - 1));
      return;
    case CC_L: case CC_NL:
      rtl_setrelopi(s, NEGCCRELOP(cc), s0, &cpu.cc_dest, 0x1u << (cpu.cc_width * 8 - 1));
      rtl_msb(s, s1, &cpu.cc_dest, cpu.cc_width);
      rtl_xor(s, dest, s0, s1);
      return;
    case CC_LE: case CC_NLE:
      rtl_setrelopi(s, RELOP_EQ, s0, &cpu.cc_dest, 0x1u << (cpu.cc_width * 8 - 1));
      rtl_msb(s, s1, &cpu.cc_dest, cpu.cc_width);
      rtl_xor(s, dest, s0, s1);
      MASKDEST(s0);
      rtl_setrelopi(s, RELOP_EQ, s0, p, 0);
      rtl_or(s, dest, dest, s0);
      goto negcc_reverse;
      return;
#endif
  }
}

static void lazycc_dec(Decode *s, CCop *op, rtlreg_t *tmp, uint32_t cc) {
  switch (cc) {
    // CF is already stored in cpu.cc_src1
    case CC_B: lazycc_codegen(s, op, false, RELOP_NE, &cpu.cc_src1, rz); return;
#if 0
    case CC_O: case CC_NO:
      rtl_addi(s, dest, &cpu.cc_dest, 1);
      rtl_setrelopi(s, NEGCCRELOP(cc), dest, dest, 0x1u << (cpu.cc_width * 8 - 1));
      return;
    case CC_L: case CC_NL:
      rtl_addi(s, s0, &cpu.cc_dest, 1);
      rtl_setrelopi(s, NEGCCRELOP(cc), s0, s0, 0x1u << (cpu.cc_width * 8 - 1));
      rtl_msb(s, s1, &cpu.cc_dest, cpu.cc_width);
      rtl_xor(s, dest, s0, s1);
      return;
    case CC_LE: case CC_NLE:
      rtl_addi(s, s0, &cpu.cc_dest, 1);
      rtl_setrelopi(s, RELOP_EQ, s0, s0, 0x1u << (cpu.cc_width * 8 - 1));
      rtl_msb(s, s1, &cpu.cc_dest, cpu.cc_width);
      rtl_xor(s, dest, s0, s1);
      rtl_setrelopi(s, RELOP_EQ, s0, &cpu.cc_dest, 0);
      rtl_or(s, dest, dest, s0);
      goto negcc_reverse;
      return;
#endif
  }
}

static void lazycc_adc(Decode *s, CCop *op, rtlreg_t *tmp, uint32_t cc) {
  switch (cc) {
    case CC_B:
      rtl_is_add_carry(s, s0, &cpu.cc_src1, &cpu.cc_src2);
      rtl_is_add_carry(s, s1, &cpu.cc_dest, &cpu.cc_src1);
      rtl_or(s, tmp, s0, s1);
      lazycc_codegen(s, op, true, RELOP_NE, tmp, rz);
      return;
    default: panic("unhandle cc = %d at pc = " FMT_WORD, cc, s->extraInfo->pc);
#if 0
    case CC_O: case CC_NO:
      rtl_sub(s, dest, &cpu.cc_dest, &cpu.cc_src1);
      rtl_is_add_overflow(s, dest, &cpu.cc_dest, dest, &cpu.cc_src2, cpu.cc_width);
      goto negcc_reverse;
      return;
    case CC_L: case CC_NL:
      rtl_sub(s, dest, &cpu.cc_dest, &cpu.cc_src1);
      rtl_is_add_overflow(s, s0, &cpu.cc_dest, dest, &cpu.cc_src2, cpu.cc_width);
      rtl_msb(s, s1, &cpu.cc_dest, cpu.cc_width);
      rtl_xor(s, dest, s0, s1);
      goto negcc_reverse;
      return;
    case CC_LE: case CC_NLE:
      rtl_sub(s, dest, &cpu.cc_dest, &cpu.cc_src1);
      rtl_is_add_overflow(s, s0, &cpu.cc_dest, dest, &cpu.cc_src2, cpu.cc_width);
      rtl_msb(s, s1, &cpu.cc_dest, cpu.cc_width);
      rtl_xor(s, dest, s0, s1);
      MASKDEST(s0);
      rtl_setrelopi(s, RELOP_EQ, s0, p, 0);
      rtl_or(s, dest, dest, s0);
      goto negcc_reverse;
      return;
    case CC_BE: case CC_NBE:
      MASKDEST(s0);
      rtl_setrelopi(s, RELOP_EQ, s1, p, 0);
      rtl_is_add_carry(s, t0, &cpu.cc_src1, &cpu.cc_src2);
      rtl_is_add_carry(s, s0, p, &cpu.cc_src1);
      rtl_or(s, dest, t0, s0);
      rtl_or(s, dest, dest, s1);
      goto negcc_reverse;
      return;
#endif
  }
}

static void lazycc_sbb(Decode *s, CCop *op, rtlreg_t *tmp, uint32_t cc) {
  switch (cc) {
    case CC_B:
      rtl_sub(s, s0, &cpu.cc_src1, &cpu.cc_dest);
      rtl_is_add_carry(s, s0, s0, &cpu.cc_src2);
      rtl_is_sub_carry(s, s1, &cpu.cc_src1, &cpu.cc_dest);
      rtl_or(s, tmp, s0, s1);
      lazycc_codegen(s, op, true, RELOP_NE, tmp, rz);
      return;
    case CC_L:
      rtl_is_sub_overflow(s, s0, &cpu.cc_dest, &cpu.cc_src1, &cpu.cc_src2, cpu.cc_width);
      rtl_msb(s, s1, &cpu.cc_dest, cpu.cc_width);
      rtl_xor(s, tmp, s0, s1);
      lazycc_codegen(s, op, true, RELOP_NE, tmp, rz);
      return;
    default: panic("unhandle cc = %d at pc = " FMT_WORD, cc, s->extraInfo->pc);
#if 0
    case CC_O: case CC_NO:
      rtl_is_sub_overflow(s, dest, &cpu.cc_dest, &cpu.cc_src1, &cpu.cc_src2, cpu.cc_width);
      goto negcc_reverse;
      return;
    case CC_LE: case CC_NLE:
      rtl_is_sub_overflow(s, s0, &cpu.cc_dest, &cpu.cc_src1, &cpu.cc_src2, cpu.cc_width);
      rtl_msb(s, s1, &cpu.cc_dest, cpu.cc_width);
      rtl_xor(s, dest, s0, s1);
      MASKDEST(s0);
      rtl_setrelopi(s, RELOP_EQ, s0, p, 0);
      rtl_or(s, dest, dest, s0);
      goto negcc_reverse;
      return;
    case CC_BE: case CC_NBE:
      rtl_sub(s, s0, &cpu.cc_src1, &cpu.cc_dest);
      rtl_is_add_carry(s, s0, s0, &cpu.cc_src2);
      rtl_is_sub_carry(s, s1, &cpu.cc_src1, &cpu.cc_dest);
      rtl_or(s, dest, s0, s1);
      rtl_setrelopi(s, RELOP_EQ, s0, &cpu.cc_dest, 0);
      rtl_or(s, dest, dest, s0);
      goto negcc_reverse;
      return;
#endif
  }
}

static void lazycc_logic(Decode *s, CCop *op, rtlreg_t *tmp, uint32_t cc) {
  rtlreg_t *p = &cpu.cc_dest;
  if (cpu.cc_width != 4 && (cc == CC_LE || cc == CC_L)) {
    rtl_slli(s, tmp, p, 32 - cpu.cc_width * 8);
    p = tmp;
  }

  int relop = cc2relop_logic[cc];
  assert(cc == CC_O || relop != 0);
  lazycc_codegen(s, op, false, relop, p, rz);
}

static void lazycc_shl(Decode *s, CCop *op, rtlreg_t *tmp, uint32_t cc) {
  switch (cc) {
    case CC_B: rtl_msb(s, tmp, &cpu.cc_src1, cpu.cc_width);
               lazycc_codegen(s, op, false, RELOP_NE, tmp, rz);
               break;
    default: panic("unhandle cc = %d at pc = " FMT_WORD, cc, s->extraInfo->pc);
  }
}

static void lazycc_shr(Decode *s, CCop *op, rtlreg_t *tmp, uint32_t cc) {
  switch (cc) {
    case CC_B: rtl_andi(s, tmp, &cpu.cc_src1, 0x1);
               lazycc_codegen(s, op, false, RELOP_NE, tmp, rz);
               break;
    default: panic("unhandle cc = %d at pc = " FMT_WORD, cc, s->extraInfo->pc);
  }
}

static void lazycc_sar(Decode *s, CCop *op, rtlreg_t *tmp, uint32_t cc) {
  switch (cc) {
    case CC_B: lazycc_shr(s, op, tmp, cc); break;
    default: panic("unhandle cc = %d at pc = " FMT_WORD, cc, s->extraInfo->pc);
  }
}

static void lazycc_bt(Decode *s, CCop *op, rtlreg_t *tmp, uint32_t cc) {
  switch (cc) {
    // cc_dest == rz --> CF = 0 -> CC_NB
    case CC_B: lazycc_codegen(s, op, false, RELOP_NE, &cpu.cc_dest, rz); break;
    default: panic("unhandle cc = %d at pc = " FMT_WORD, cc, s->extraInfo->pc);
  }
}

static void lazycc_fcmp(Decode *s, CCop *op, rtlreg_t *tmp, uint32_t cc) {
  switch (cc) {
    case CC_B:
      if (op->type == CCTYPE_SETCC) { rtl_mv(s, tmp, &cpu.cc_dest); }
      else { tmp = &cpu.cc_dest; }
      break;
    case CC_BE:  rtl_or(s, tmp, &cpu.cc_dest, &cpu.cc_src1); break;
    default: panic("unhandle cc = %d at pc = " FMT_WORD, cc | op->invert, s->extraInfo->pc);
  }
  lazycc_codegen(s, op, true, RELOP_NE, tmp, rz);
}

static void lazycc_mul(Decode *s, CCop *op, rtlreg_t *tmp, uint32_t cc) {
  switch (cc) {
    case CC_O: lazycc_codegen(s, op, false, RELOP_NE, &cpu.cc_dest, rz); break;
    default: panic("unhandle cc = %d at pc = " FMT_WORD, cc, s->extraInfo->pc);
  }
}

static void lazycc_popf(Decode *s, CCop *op, rtlreg_t *tmp, uint32_t cc) {
  int shift = 0;
  switch (cc) {
    case CC_O:  shift = 11; goto popf_check_jcc;
    case CC_B:  shift = 0;  goto popf_check_jcc;
    case CC_E:  shift = 6;  goto popf_check_jcc;
    case CC_P:  shift = 2;  goto popf_check_jcc;
    case CC_S:  shift = 7;  goto popf_check_jcc;
    case CC_BE: rtl_srli(s, tmp, &cpu.cc_dest, 6);  // move ZF to bit 0 (CF)
                rtl_or(s, tmp, tmp, &cpu.cc_dest);
                shift = 0;  goto popf_check_jcc;
    popf_check_jcc:
      rtl_andi(s, tmp, &cpu.cc_dest, 1 << shift);
      if (op->type == CCTYPE_SETCC && shift != 0) { rtl_srli(s, tmp, tmp, shift); }
      lazycc_codegen(s, op, true, RELOP_NE, tmp, rz);
      break;
    default: panic("unhandle cc = %d at pc = " FMT_WORD, cc, s->extraInfo->pc);
  }
}

static def_rtl(lazycc_internal, CCop *op, uint32_t cc) {
  rtlreg_t *tmp = (op->type == CCTYPE_SETCC ? op->dest : s2);
  op->invert = cc & 0x1;
  cc &= ~0x1;

  // check this first
  if (cpu.cc_op == LAZYCC_POPF) { lazycc_popf(s, op, tmp, cc); return; }

  switch (cc) {
    case CC_P: lazycc_P(s, op, tmp); return;
    case CC_E: lazycc_E(s, op, tmp); return;
    case CC_S: lazycc_S(s, op, tmp); return;
  }

  switch (cpu.cc_op) {
    case LAZYCC_ADD:  lazycc_add  (s, op, tmp, cc); break;
    case LAZYCC_SUB:  lazycc_sub  (s, op, tmp, cc); break;
    case LAZYCC_NEG:  lazycc_neg  (s, op, tmp, cc); break;
    case LAZYCC_INC:  lazycc_inc  (s, op, tmp, cc); break;
    case LAZYCC_DEC:  lazycc_dec  (s, op, tmp, cc); break;
    case LAZYCC_ADC:  lazycc_adc  (s, op, tmp, cc); break;
    case LAZYCC_SBB:  lazycc_sbb  (s, op, tmp, cc); break;
    case LAZYCC_LOGIC:lazycc_logic(s, op, tmp, cc); break;
    case LAZYCC_SHL:  lazycc_shl  (s, op, tmp, cc); break;
    case LAZYCC_SHR:  lazycc_shr  (s, op, tmp, cc); break;
    case LAZYCC_SAR:  lazycc_sar  (s, op, tmp, cc); break;
    case LAZYCC_BT:   lazycc_bt   (s, op, tmp, cc); break;
    case LAZYCC_FCMP: lazycc_fcmp (s, op, tmp, cc); break;
    case LAZYCC_MUL:  lazycc_mul  (s, op, tmp, cc); break;
    default: panic("unhandle cc_op = %d at pc = " FMT_WORD, cpu.cc_op, s->extraInfo->pc);
  }
}

def_rtl(lazy_setcc, rtlreg_t *dest, uint32_t cc) {
  if (cpu.cc_dirty == false) {
    cpu.cc_dynamic = cpu.cc_op | 0x100;
    // printf("dynamic hit\n");
  }
  CCop op;
  op.dest = dest;
  op.type = CCTYPE_SETCC;
  rtl_lazycc_internal(s, &op, cc);
}

def_rtl(lazy_jcc, CCop *op, uint32_t cc) {
  if (cpu.cc_dirty == false) {
    cpu.cc_dynamic = cpu.cc_op | 0x100;
  }
  clean_lazycc();
  op->type = CCTYPE_JCC;
  rtl_lazycc_internal(s, op, cc);
}
#endif
